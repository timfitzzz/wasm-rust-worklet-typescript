## TypeScript / Rust Audio Worklet example with Firefox support
### Based on [Peter Suggate's JS walkthrough](https://www.toptal.com/webassembly/webassembly-rust-tutorial-web-audio)
#### 
#### by [Tim Fitzgerald](https://github.com/timfitzzz) -- [source](https://github.com/timfitzzz/wasm-rust-worklet-typescript)

First, everybody interested in getting started building Web Audio nodes with WASM and Audio Worklet should go visit [Peter Suggate](https://www.toptal.com/resume/peter-suggate)'s awesome walkthrough of how to use Rust, WebAssembly, and JavaScript to create custom Web Audio nodes, ["WebAssembly/Rust Tutorial: Pitch-perfect Audio Processing"](https://www.toptal.com/webassembly/webassembly-rust-tutorial-web-audio). Provided therein is a full walkthrough of how to create a JavaScript version of this example. 

As a practice exercise, I rewrote the example code in TypeScript, including the JS code meant to run in the second, Audio Worklet thread. This introduced some new issues, particularly when I tried to use tsc to compile the worker code into the static /public folder in which the JS implementation had been placed by Suggate: to load the compiled TypeScript code as a module of the types supported by both TSC and the browser, we'd need to import additional modules (like RequireJS), which can't be done within the code being loaded as a module! Additionally, as Suggate notes, Firefox doesn't support *any* type of importing at all from within the worker thread, something that entirely prevented his implementation from supporting that browser.

Ultimately, both problems had the same solution: the best way I found to get compiled TypeScript code running inside the Worklet thread was to rely on Webpack and the [worklet-loader](https://github.com/reklawnos/worklet-loader) plugin, which allowed me to bundle the (JS) Worklet code into a blob that then could be loaded into the Web Audio context, without needing to precompile it into the /public folder at all.

Apparently, worklet-loader is not meant to be relied upon as a production solution, underscoring the somewhat prototypical state of the entire Audio Worklet ecosystem. The Web Audio API is an extremely competent interface for handling the most common audio needs of front-end developers, but when it comes to some of the more adventurous potential uses, it can sometimes be difficult to find strong examples from which to draw inspiration. I hope you find this boilerplate a useful contribution, and again, please [give a click to Peter Suggate for his great and helpful walkthrough](https://www.toptal.com/webassembly/webassembly-rust-tutorial-web-audio).

## Changes From Suggate Tutorial

### Include copy of wasm-pack output in /src folder

While we'll still need to load the .wasm file provided by wasm-pack from the /public folder, we'll use the binding file it generates directly within our application code. So make sure to copy wasm-tuner/wasm_tuner.js into your /src folder as well.

### Add worklet-loader and text-encoding to your project

```
yarn add worklet-loader text-encoding
```

### Modify wasm-pack-generated json binding file

In ```/src/wasm-tuner/wasm_tuner.js```, import the TextEncoder.js file directly on line 1:

```
const { TextEncoder, TextDecoder } = require('text-encoding');
```

And on line 203, replace the reference to ```input.meta.url``` to the Webpack-specific variable, __webpack_public_path__:

```
input = new URL('wasm_tuner_bg.wasm', __webpack_public_path__);
```

### In setupAudio.ts, import your worklet processor using worklet-loader:

```
import PitchProcessorUrl from 'worklet-loader!./PitchProcessor.worklet.ts';
```

### Finally, when you add the module to the audio worklet context, just use the PitchProcessorUrl generated by worker-loader:

```
await context.audioWorklet.addModule(PitchProcessorUrl);
```